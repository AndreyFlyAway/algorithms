/* номер посылки:  */
/*
-- ПРИНЦИП РАБОТЫ --
Принип работы стека завязае на работе двусвязного списка.
Класс содержит два указаталея - на начало и на конец стека() 
далее голова и хвост). Элементы можно извлекать (как и помещать) 
из начала стека и из конца. Выход за пределы размера стека
проверяется. Порядокк элементов сохраняется за счет 
помещению элемента в связанный список, и связанный список
позволяет получить константное время добавлениее и изъятие 
объекта из стека.

Конструктор.
Инициализирую максимальное значение стека, ссылки на голову и хвост 
как nullptr, и текщуее значение счетчика элементов нулем.

Добавление в конец (push_back)
1. Проверяю на заполенность очереди, и вывожу ошибку если требуется,
выхожу из метода, если список полон.
2. Создаю элемент связанного списка,
в конструкторе передаю ссылк на хвост уже имеющегося связанного списка,
чтобы он испольловазлся как предыдущий элемент, даже если хвост
отсутсвует, то ошибкой это является не будет. 
3. Если в стеке отсутсвуют элементы, то в хвост помещаю
созданный в п. 2 объект, меняю указатель на голову. Иначе меняю
указательму на следующий элемент у хвоста на созданый эллемент в пункте 2. 
5. Заменяю указатель на хвост указателем на созданный элемент.
4. Увеличиваю счетчик эелементов.


Добавление в начало (push_front) 
1. Проверяю на заполенность очереди, и вывожу ошибку если требуется,
выхожу из метода, если список полон.
2. Создаю элемент связанного списка,в конструкторе передаю ссылку на 
голову уже имеющегося связанного списка, чтобы он испольловазлся как с
следующий элемент, даже если голова отсутсвует, то ошибкой это является 
не будет. 
3. Если в стеке отсутсвуют элементы, то начало связаного списка помещаю
созданный в п.2 объект - меняю указатель на голову, указатель на 
хвост приравниваю указателю на голову. Иначе меняю у текущей головы указатель 
на предыдущий элемент на указатель объекта созданный в п 2.
4. Заменяю указатель на голову указателем на созданный элемент.
5. Увеличиваю счетчик эелементов.

Изъять элемент из конца (pop_back)
1. Если элементов в стеке нет, то вывожу ошибку.
2. Вывожу значение элемента по ссылки на хвост.
3. Получаю ссылку на предыдущий элемен хвоста.
4. Удаляю элеемент, на который ссылается хвост, заменяю ссылку на хвост
ссылкой элемента из п. 3.
5. Если ссылка из п. 3 указывает на элемен, то удаляю у него ссылку
на следующий элемент.
6. Уменьшаю счетчик элементов.
7. Если количетсво элементов в списк равно или меньше 1, то заменяю ссылку 
на голову ссылкой на хвост, это делаю чтобы заменить ссылку на следуюший элмент
у головы, который удалил в п. 4. (хвост и голова будут указывать на один объект), 
в тоже время этим действием я зачищу ссылку на голову, если был удален последний
элемент, и не потребуется отдельная проверка на отсутствие элементов в стеке.


Изъять элемент из начала (pop_front)
1. Если элементов в стеке нет, то вывожу ошибку.
2. Вывожу значение элемента в по ссылке на голову.
3. Получаю ссыдку на следующий элемен головы.
4. Удаляю элеемент, на который ссылается голова, заменяю ссылку на голову
ссылкой элемента из п. 3.
5. Если ссылка из п. 3 указывает на элемен, то удаляю у него ссылку
на предыдущий элемент.
6. Уменьшаю счетчик элементов.
7. Если количетсво элементов в списк равно или меньше 1, то заменяю ссылку 
на хвост ссылкой на голову, это делаю чтобы заменить ссылку на прредыдущий
элменту головы, который удалил в п. 4. (хвост и голова будут указывать на один объект),
в тоже время этим действием я зачищу ссылку на хвост, если был удален последний элемент, 
и не потребуется отдельная проверка на отсутствие элементов в стеке.

Дееструктор
Удаляю по ссылкам существующие элементы.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Добавление в очередь стоит O(1), потому что добавление к конец и начало
двусвязнного срика стоит O(1).

Извлечение из обоих концов стека стоит O(1), т.к. базовая структура
связанный спикос - треубется сделать константное количество проверок и
заменить ссылки, т.е. добавление и извлечение n элементов составит O(n).

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Из описания алгоритма следует, что объект который добавиться в конец
будет извлечен соотвесвтующим методом, аналогично с помщением объекта
с начало. Порядок помещения объекта обеспечивается за счет двусвязанного
спика. В каждом из методов проверяется выход за пределы, заменются
ссылки на объекты головы и хвоста, которые были удаленны, как и 
заменяются ссылки у элементов, которые указывали на удаленные 
предыущий и следующий элемент.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Если очередь содержит n элементов, то входной стек содержит n 
значений каждого узла и по 2е ссылки на соседние узлы связанного спика.
То есть для n элемеелнтов будет использовано 3n памяти - O(3n) == O(n)
*/
#include <iostream>
#include <string>
#include <vector>
#include <stdexcept>

struct Node {
    Node(const int value, Node* next, Node* prev) 
        : value(value)
        , next(next)
        , prev(prev)
        {}
    int value;
    Node* next;  
    Node* prev;
};

class MyQueueSized {
public:
    MyQueueSized(int queueSize): 
        _maxQueueSize(queueSize), 
        _curQueueSize(0), 
        _head(nullptr),
        _tail(nullptr) {}

    void push_back(int value) {
        if (_curQueueSize == _maxQueueSize) {
             throw std::out_of_range("error");
        } else {
            Node* curNode = new Node(value, nullptr, _tail);
            if (_curQueueSize == 0) {
                _head = curNode;
                _tail = _head;
            } else {
                _tail->next = curNode;
                _tail = curNode;
            }
            ++_curQueueSize;
        }
    }

    void push_front(int value) {
        if (_curQueueSize == _maxQueueSize) {
             throw std::out_of_range("error");
        } else {
            Node* curNode = new Node(value, _head, nullptr);
            if (_curQueueSize == 0) {
                _head = curNode;
                _tail = _head;
            } else {
                _head->prev = curNode;
                _head = curNode;
            }
            ++_curQueueSize;
        }
    }

    int pop_back() {
        if (_curQueueSize == 0) {
             throw std::out_of_range("error");
        } else {
            int res = _tail->value;
            Node* tail_prev = _tail->prev;
            delete _tail;
            _tail = tail_prev;
            if (_tail) {
                _tail->next = nullptr;
            }
            --_curQueueSize;
            if (_curQueueSize <= 1) {
                _head = _tail; 
            }
            return res;
        }
    }
    
    int pop_front() {
        if (_curQueueSize == 0) {
             throw std::out_of_range("error");
        } else {
            int res = _head->value;
            Node* head_next = _head->next;
            delete _head;
            _head = head_next;
            if (_head) {
                _head->prev = nullptr;
            }
            --_curQueueSize;
            if (_curQueueSize <= 1) {
                _tail = _head; 
            }
            return res;
        }
    }


    ~MyQueueSized() {
        Node* tmp;
        while (_head)
        {
           tmp = _head->next;
           delete _head;
           _head = tmp;
        }
    }

private:
    const int _maxQueueSize;
    int _curQueueSize;
    Node* _head;
    Node* _tail;
};

int useStack() {
    int n; // количество комманд
    std::cin >> n;
    std::string command;
    int value; //
    std::cin >> value;
    MyQueueSized stack {value};
    for(int i=0 ; i < n; ++i) {
        try {
            std::cin >> command;
            if (command == "push_front") {
                std::cin >> value;
                stack.push_front(value);
            } else if (command == "push_back") {
                std::cin >> value;
                stack.push_back(value);
            } else if (command == "pop_front") {
                std::cout << stack.pop_front() << std::endl;
            } else if (command == "pop_back") {
                std::cout << stack.pop_back() << std::endl;
            }
        } catch(const std::out_of_range &e) {
            std::cout << e.what() << std::endl;
        }
    }
    return 0;
}

int main() {
    useStack();
}